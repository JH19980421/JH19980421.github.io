---
layout: post
---


### 클래스

객채를 생성하는 틀. 하나의 큰 틀에 관련된 여러 개의 타입, 메소드들을 묶어두어 관리하기 편하다.

클래스는 참조 타입이므로 초기화할 때, 참조 변수에 주소를 할당한다. 할당을 안할 시에는 null로 저장된다.

```java
class Student {
    String name;
    int age;
}
```

![image](./img/class1.png)
                              Student student = new Student();

### 깊은 복사 & 얕은 복사

      얕은 복사 

      한 인스턴스에 다른 인스턴스를 “=”를 통해 복사 하는 경우.

```java
class Member {
    String name;
    int age;

   public Member(String name, int age) {
       this.name = name;
       this.age = age;
   }

   void addAge() {
       age++;
   }
}
public class Copy {
    public static void main(String[] args) {
        Member member1 = new Member("아무개", 10);
        Member member2 = member1;

        member2.addAge();

        System.out.println(member1.name + " " + member1.age); // 아무개 11
        System.out.println(member2.name + " " + member2.age); // 아무개 11
     }
}
```

Member member2 = member1; 이 부분에서 member2에는 member1의 정보가 담긴 개별 인스턴스가 아닌,  member1의 주소가 담겨있기 때문에 member2.addAge()를 실행하면 member1의 age도 바뀐다.

![image](./img/class2.png)

깊은 복사

다른 메모리 저장공간에 복사하려는 인스턴스의 값을 넣고, 그 주소를 참조하는 경우.

```java
class Member {
    String name;
    int age;

   public Member(String name, int age) {
       this.name = name;
       this.age= age;
   }

   public Member(Member member) {
       this.name = member.name;
       this.age = member.age;
   }

   void addAge() {
       age++;
   }
}
public class Copy {
    public static void main(String[] args) {
        Member member1 = new Member("아무개", 10);
        Member member2 = new Member(member1);

        member2.addAge();

        System.out.println(member1.name + " " + member1.age); // 아무개 10
        System.out.println(member2.name + " " + member2.age); // 아무개 11
     }
}

```

다른 주소의 인스턴스를 만든 다음, 생성자에 복사하려는 인스턴스를 넣어 값을 복사한 후, 새로운 참조변수에 주소를 저장한다

![image](./img/class3.png)

### String  s = “abc” 와 String s = new String(”abc”)의 차이점

```java
public class StringPool {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
        String s3 = new String("abc");
        String s4 = new String("abc");
        
        System.out.println(s1==s2); // true
        System.out.println(s1==s3); // false
        System.out.println(s2==s3); // false
        System.out.println(s3==s4); // false
    }
}

```

String s = “abc”는 리터럴 방식으로 “abc”가 문자열 풀(String Pool)에 저장된다. 다른 String 타입의 변수가 abc값을 저장하면 새로운 공간에 “abc”값을 저장하는 것이 아니라, 문자열 풀 안에 있는 “abc”의 주소를 참조한다.

String s = new String(”abc”)는 new 연산자 방식으로  문자열 풀이 아닌, 새로운 메모리 주소에 값을 넣어 참조한다. 그러므로 리터럴 방식으로 저장된 String타입의 변수는 서로 같은 주소를 참조하기에 true가 나오는 반면, new 연산자 방식은 다른 주소를 참조하기에 false가 나온다.

![image](./img/class4.png)
